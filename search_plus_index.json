{"./":{"url":"./","title":"简介","keywords":"","body":"C 语言知识库 C 语言是一种相对 “低级” 的语言（没有贬义），意味着它可以处理大部分计算机能够处理的对象，比如字符、数字和地址。这些对象可以通过具体机器实现的算术运算符和逻辑运算符组合在一起并移动。 C 语言不提供直接处理诸如字符串、集合、列表或数组等复合对象的操作。虽然可以将整个结构作为一个单元进行拷贝，但 C 语言没有处理着整个数组或字符串的操作。除了由函数的局部变量提供的静态定义和堆栈外，C 语言没有定义任何存储器分配工具，也不提供堆和无用内存回收工具。最后，C 语言本身没有提供输入输出功能，没有 READ 或 WRITE 语句，也没有内置的文件访问方法。所有这些高层的机制必须由显示调用的函数提供。C 语言的大部分实现已合理地包含了这些函数的标准集合。 类似地，C 语言只提供了简单的单线程控制流，即测试、循环、分组和子程序，它不提供多道程序设计、并行操作、同步和协同例程。 简史 时间：1969年 ～ 1973年 地点：美国 AT&T 公司的贝尔实验室（Bell Labs） 人物：丹尼斯·里奇（Dennis Ritchie；第一作者）、肯·汤普逊（Ken Thompson） 事件：为了移植和开发 Unix 操作系统，在 B 语言（作者：Ken Thompson）和 BCPL 语言（作者：Martin Richards）的基础上设计了 C 语言 特点：高效、灵活、功能丰富、高可移植性 书籍：《The C Programming Language》（Dennis Ritche & Brian Kernighan） C 标准 K&R C - Brian Kernighan 和 Dennis Ritchie 在《The C Programming Language》第 1 版描述的参考手册 ANSI C / ISO C / Standard C C89 - 1983 ～ 1989 年美国国家标准协会（ANSI）基于《The C Programming Language》第 1 版的参考手册制定的标准（该书第 2 版又根据 ANSI C 标准做了修订），通常被称为 C89，有时 ANSI C 也专指 C89 C90 - 被 ISO 批准的与 C89 相同的标准，有时被称为 C90 C95 - 1995 年 ISO 根据 ANSI C 标准做了扩展，被称为 C95 C99 - 2000 年 3 月，ANSI 采用了 ISO/IEC 9899:1999 标准并做了一些补充，通常被称为 C99 C11 - 2012 年 ISO 制定的标准 C18 - C 语言的当前标准 翻译过程 预处理（preprocessing） 编译（compilation） 汇编（assembly） 链接（linking） LICENSE 参考 ANSI C Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"quickstart.html":{"url":"quickstart.html","title":"入门","keywords":"","body":"C 语言入门 环境设置 文本编辑器 $ vim --version 编译器 $ gcc --version 编写 Hello World 程序 C89（hello-c89.c） #include /** 导入标准输入输出库 **/ /** 主函数，不接受参数或接受 void 参数 **/ void main() { /** 调用库函数 printf **/ printf(\"Hello, world\\n\"); } C99（hello-c99.c） #include // 导入标准输入输出库 // 主函数，不接受参数或接受 void 参数 int main() { // 调用库函数 printf printf(\"Hello, world\\n\"); // 终止 main() 函数并返回整数 0 return 0; } 编译运行 默认情况下，gcc 不符合任何 ANSI C / ISO C 标准。当前默认值等效于 -std=gnu90 gcc 4.7 gcc 5.1.0 --> 2015-04-22 --> -std=gnu11 # 使用 C89 标准编译 $ gcc -std=c89 hello-c89.c # 生成了 a.out 可执行文件 $ ls a.out hello-c89.c # 运行 $ ./a.out Hello, world Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/":{"url":"type/","title":"数据类型","keywords":"","body":"数据类型（Data Type） C 语言是一门强类型（strongly typed）语言。 C 语言的数据类型用于声明不同类型的变量或函数。变量的类型决定了它在存储中占用的空间大小以及如何解释存储的位模式（ bit pattern）。 基本类型（Basic Types） 基本类型指的是算术类型（arithmetic types），进一步分为整数类型（integer types）和浮点类型（floating-point types）。 Type 类型 存储大小（取值范围） int 整型（integer type） 通常反应所用机器中整数的最大自然长度 16bit（-32768 ~ +32767） * 32bit short 短整型 char 字符型 8bit，可以存放本地字符集中的一个字符 float 单精度浮点型（floating-point type） * 32bit（至少有 6 位有效数字；10^{-38} ~ 10^{+38}） double 双精度浮点型 The C language provides the four basic arithmetic type specifiers char, int, float and double, and the modifiers signed, unsigned, short and long. 整型（integer types） Type Storage size Value range char 1 byte -128 to 127 or 0 to 255 unsigned char 1 byte 0 to 255 signed char 1 byte -128 to 127 int 2 or 4 bytes -32,768 to 32,767 or -2,147,483,648 to 2,147,483,647 unsigned int 2 or 4 bytes 0 to 65,535 or 0 to 4,294,967,295 short 2 bytes -32,768 to 32,767 unsigned short 2 bytes 0 to 65,535 long 4 bytes -2,147,483,648 to 2,147,483,647 unsigned long 4 bytes 0 to 4,294,967,295 整数常量表明该常数是一个 int 型整数；带小数点的常数（如：5.0）表明该常数是一个单精度浮点数，而不是双精度浮点数。 unsigned int 数据类型的大小取决于具体的机器。为了在特定平台上获得类型或变量的确切大小，可以使用 sizeof 运算符。表达式 sizeof(type) 将以字节为单位返回对象（变量、函数等）或类型的存储大小，返回值的类型为 long unsigned int（等同于 unsigned long int；格式符：%lu）。 #include #include // Sizes of integer types int main() { int c = 'a'; printf(\"Storage size for int: %lu byte(s)\\n\", sizeof(int)); printf(\"%d\\n\", c); // 97; char 也是整型！ return 0; } 浮点型（Floating-Point Types） Type Storage size Value range 精确值 类型说明符 float 4 byte 1.2E-38 to 3.4E+38 小数点后 6 位 %f double 8 byte 2.3E-308 to 1.7E+308 小数点后 15 位 %f long double 10 byte 3.4E-4932 to 1.1E+4932 小数点后 19 位 %f #include #include int main() { printf(\"Storage size for float : %d \\n\", sizeof(float)); printf(\"Minimum float positive value: %E\\n\", FLT_MIN ); // %E 科学计数法 printf(\"Maximum float positive value: %E\\n\", FLT_MAX ); printf(\"Precision value: %d\\n\", FLT_DIG ); return 0; } 指针类型在 64 位机器上占用 8 个字节，在 32 位机器上占用 4 个字节（注：64位/32位指的是 CPU 通用寄存器的数据宽度）；CPU 与内存之间地址总线的宽度决定了指针类型的大小 枚举类型（Enumerated types） 派生类型（Derived types） （貌似没有格式说明符） 数组（array types） 结构体（structure types） 枚举（Enumeration） 联合类型（union types） 指针类型（pointer types） 函数类型（function types） - 指函数返回值的类型 数组类型和结构体类型统称为聚合类型（aggregate types） void 类型 void 类型指的是没有可用的值。用于三种情况： 类型 描述 示例 函数返回为 void 没有返回值的函数的返回类型为 void void exit(int status); 函数参数为 void 没有参数的函数可以接受 void int rand(void); 指向 void 的指针 void * 类型的指针代表对象的地址，而不是类型 void *malloc(size_t size); （返回一个指向 void 的指针，该指针可以转换为任何数据类型。） 数组 字符数组 字符数组是 C 语言中最常用的数组类型。 强制类型转换 ``` ## 初始默认值（零值） 当定义未初始化的变量，系统会使用默认值自动初始化它。 | 数据类型 | 零值 | | -------- | ---- | | int | 0 | | char | \\0 | | float | 0 | | double | 0 | | pointer | NULL | 最好养成正常初始化变量的习惯，因为为初始化的变量会在其内存位置产生一些垃圾值。 ## 特殊类型 * size_t 类型 - 一种可以保存任何数组索引的类型 `sizeof()` 的返回值类型 `strlen()` 的返回值类型 `malloc()` 将 size_t 作为函数参数，确定了可以分配的最大大小。 ```sh # 结果因环境的不同而不同 $ echo | gcc -E -xc -include 'stddef.h' - | grep size_t typedef long unsigned int size_t; 由于 size_t 的具体类型因环境而异，为了跨平台需要使用 %zd（十进制 size_t） 或 %zx（十六进制 size_t） 的格式说明符（format specifier），参考 Platform independent size_t Format specifiers in c? 详见：https://linux.die.net/man/3/printf - length modifiers 格式占位符（Format Specifiers） 格式占位符 数据类型 %d int %f float / double %c char %s char[] %p 指针（地址） /* * MacOS(GCC) => 0x7ffeeb39190c 0x7ffeeb391910 0x7ffeeb391910 5 */ int main() { int arr[3] = {3, 4, 5}; // 0x1 即一个存储单元，对于 int 数据而言是 4 个字节 printf(\"%p %p %p %d\\n\", &arr[0], &arr[1], &arr[0] + 0x1, *(&arr[1] + 0x1)); return 0; } 参考 C data types Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/array.html":{"url":"type/array.html","title":"数组","keywords":"","body":"数组（Array） 数组是一种数据结构，可以存储相同类型元素的固定大小的顺序集合。 特点 数组所有元素的类型相同 数组的大小是固定的 数组的内存地址是连续的 一个单独的数组名代表第一个元素的地址 数组越界将返回默认值 声明数组 Type Array_Name[Array_Size]; // 一维数组 Array_Size 必须是大于 0 的整数常量 int a[10]; 初始化数组 // 一个一个地初始化 a[0] = 1; a[1] = 2; ... a[9] = 10; // 初始化声明（{} 之间元素的数量不能大于 [] 中的值） int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // 同上 int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 所有数组都将 0 作为其第一个元素的索引。数组的最后一个索引将是数组的总大小减 1 。 +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +----+ | 1 | | 2 | | 3 | | 4 | | 5 | | 6 | | 7 | | 8 | | 9 | | 10 | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +----+ 0 1 2 3 4 5 6 7 8 9 数组大小和长度 数组大小 // 数组大小、容量 size_t size = sizeof(a); // 单位：字节 // 数组长度（元素个数） size_t length = sizeof(a) / sizeof(a[0]); 使用宏定义： #define LENGTHOF(arr) (sizeof(arr) / sizeof(arr[0])) // 返回值类型为 size_t 访问数组元素 数组元素可以通过索引（indexing）数组名来访问，例如 a[0]。如果索引值大于或等于数组大小，将返回数组类型所对应的默认值，而不是数组越界异常。 int b = a[9]; int c = a[10]; // 返回 0，而不是数组越界异常 #include #define LEN(arr) (sizeof(arr) / sizeof(arr[0])) // 返回值类型为 size_t void printarray(int a[]) { size_t i; for (i = 0; i 数组作为函数参数 传递一维数组的数组名作为函数参数（本质上传递的是数组第一个元素的地址）。由于数组中的内存是连续的，您仍然可以使用指针算法（如（b + 1））指向第二个元素或等效 b[1]。可以用以下三种方式声明形式参数： void func(int* arr); // 指向数组第一个元素的指针作为形参 void func(int arr[10]); // 有大小的数组作为形参（实参数组的长度可以大于形参数组的长度） void func(int arr[]); // 无大小的数组作为新参 #include /** * 打印一维数组 * 必须传递数组长度，不能通过 sizeof(a)/sizeof(a[0]) 来获取， * 因为形参 arr 获取到的是数组第一个元素的地址 */ void print_array(int *arr, size_t size) { size_t i; for (i = 0; i 从函数返回数组 C 语言不允许将整个数组作为参数返回给函数，但可以通过指定不带索引的数组名称来返回指向数组的指针。 C 语言不主张将局部变量的地址返回到函数外部，因此必须将局部变量定义为静态（static）变量。 int *func() {} ``` ## 指向数组的指针 ```c double *p; double balance[10]; p = balance; 数组越界 C 语言并没有规定数组访问越界时编译器该如何处理，导致程序可以自由访问所有内存空间，并且每次越界访问得到的值可能还不一样。 int main(int argc, char* argv[]) { int arr[10] = {3, 4, 5}; printf(\"%d\\n\", arr[100]); return 0; } 内存地址 一维数组元素 arr[i] 的内存地址： // base_address 即 arr、arr[0] 的地址 arr[i]_address = base_address + i * type_size 二维数组元素 arr[i][j]（0 // base_address 即 arr、arr[0][0] 的地址 a[i][j]_address = base_address + (i * n + j) * type_size /* * 从左到右、从上到下连续 * * 0x7ffc1eb977e0 0x7ffc1eb977e4 0x7ffc1eb977e8 * 0x7ffc1eb977ec 0x7ffc1eb977f0 0x7ffc1eb977f4 */ int main() { int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; for (int i = 0; i 动态数组 在内存的 “堆” 中开辟地址空间，并且是在运行时开辟。 #include #include // 10 11 12 13 14 15 16 17 18 19 int main() { size_t n = 10; int* arr = (int *) malloc(sizeof(int) * n); for (int i = 0; i malloc(size_in_bytes) 的返回值为 void *，表示类型未知的指针，因此需要强制类型转换以确定将要存储的地址的类型。 二维数组（2D Arrays） 二维数组实质上是以一维数组为元素而组成的新数组。同理，三维数组是以二维数组为元素而组成的数组，以此类推。 声明 type name[x][y]; 数据结构 二维数组 a[x][y] 可以看作是具有 x 行 y 列的表。数组 a[3][4] 的数据结构如下： Column0 Column1 Column2 Column3 +---------+---------+---------+---------+ Row0 | a[0][0] | a[0][1] | a[0][2] | a[0][3] | Row1 | a[1][0] | a[1][1] | a[1][2] | a[1][3] | Row2 | a[2][0] | a[2][1] | a[2][2] | a[2][3] | +---------+---------+---------+---------+ 初始化 // 每一行使用嵌套的大括号 {} // 若缺省元素会自动在相应行补默认值 int a[3][4] = { {1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, }; // 省略行的嵌套大括号 {} // 若缺省元素会自动在末尾补默认值 int a[3][4] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}; 访问数组元素 #include #define LEN(arr) (sizeof(arr) / sizeof(arr[0])) int main() { // Row2 缺省两个元素 int a[3][4] = { {1, 2, 3, 4}, {5, 6}, {9, 10, 11, 12}, }; size_t i, j; for (i = 0; i 参考 Arrays are not the same as pointers! Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/char.html":{"url":"type/char.html","title":"字符","keywords":"","body":"字符（char） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/enum.html":{"url":"type/enum.html","title":"枚举","keywords":"","body":"枚举（Enumeration） 枚举成员的默认值从 0 开始，依次递增 1；从有枚举值的成员开始递增 枚举成员可以像全局变量一样直接使用，通常作为枚举变量的值 定义 // 枚举类型 enum WEEKDAY { MON, TUE, WED, THU, FRI, SAT, SUN // 枚举值依次是 0 1 2 3 4 5 6 }; // 定义枚举变量并显式初始化 enum WEEKDAY day = SUN; /*----- or -----*/ typedef enum { MON=1, TUE, WED, THU, FRI, SAT, SUN // 枚举值依次是 1 2 3 4 5 6 7 } WEEKDAY; WEEKDAY day = SUN; // 枚举类型 typedef enum { MON=1, TUE, WED, THU, FRI, SAT, SUN // 枚举值依次是 1 2 3 4 5 6 7 } WEEKDAY; // 定义枚举变量并初始化 WEEKDAY day = MON; // 定义枚举类型 + 定义枚举变量 enum WEEKDAY { MON, TUE, WED, THU=4, FRI, SAT, SUN // 枚举值依次是 0 1 2 4 5 6 7 } day; // 定义枚举变量 enum { MON, TUE, WED, THU=4, FRI, SAT, SUN // 枚举值依次是 0 1 2 4 5 6 7 } day; 示例 // 用枚举定义顺序 typedef enum { ASC = 1, // 递增 DESC = 0 // 递减 } ORDER; Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/pointer.html":{"url":"type/pointer.html","title":"指针","keywords":"","body":"指针（Pointer） 指针提供了与具体机器无关的地址算术运算。 指针可以执行函数吗？ 指针类型 T * variable T* variable T *variable 运算符 $$ pointer = \\&(*pointer) $$ 运算符 描述 示例 & 获取数据的内存地址 &arr[1] 获取 arr[1] 的地址 * 对内存地址进行取反，即获取该内存地址存储的数据 *arr 获取 arr[0] 的值 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/string.html":{"url":"type/string.html","title":"字符串","keywords":"","body":"字符串（Character string） 定义 // 字符数组 char strOne[6] = {'H', 'e', 'l', 'l', 'o', '\\0'}; char strTwo[] = {'H', 'e', 'l', 'l', 'o', '\\0'}; char strThree[6] = \"Hello\"; char strFour[] = \"Hello\"; char* string = \"Hello\" 示例 int main () { char string[] = {'H', 'e', 'l', 'l', 'o', '\\0'}; printf(\"%s\\n\", string); // Hello return 0; } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/structure.html":{"url":"type/structure.html","title":"结构体","keywords":"","body":"结构体（Structure） 定义 // 定义名为 person 的结构体 struct person { char* name; // 结构体成员 int age; }; // 定义结构体变量 struct person p1 p2; struct { char* name; int age; } p1 p2; typedef struct { char* name; int age; } person; // 定义结构体变量 person p1 p2; // 定义指向结构体变量的指针 person* p; 运算符 运算符 用途 示例 . 结构体变量访问其成员 structure.member -> 指向结构体变量的指针访问其成员 pointer->member == (*pointer).member Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"type/union.html":{"url":"type/union.html","title":"Union","keywords":"","body":"Union Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"function/":{"url":"function/","title":"函数","keywords":"","body":"函数 C 语言中的函数等价于 Fortran 语言中的子程序或函数，也等价于 Pascal 语言中的过程或函数。 函数可以返回基本类型、结构、联合或指针类型的值 任何函数都可以递归调用 局部变量通常是 “自动的”，即在每次函数调用时重新创建 函数定义可以不是嵌套的，但可以用块结构的方式声明变量 一个 C 语言程序的不同函数可以出现在多个单独编译的不同源文件中 变量可以只在函数内部有效，也可以在函数外部但仅在一个源文件中有效，还可以在整个程序中都有效 一个 C 语言程序，无论其大小如何，都是有 函数 和 变量 组成 函数（function）也可以叫做方法（method）、子例程（sub-routine）或过程（procudure）。 参数 如果函数使用了参数，它必须声明接受参数值的变量。这些变量叫做函数的形式参数（formal parameters）或形参。 形式参数的行为与函数内部其他局部变量相似：在进入函数时创建，在退出时销毁。 在调用函数时，有两种方式将参数传递给函数： 引用调用（Call by reference） 该方法复制参数的地址到形式参数（formal parameter）。在函数内部，该地址用于访问调用中使用的实际参数（actual argument）。这意味着对形式参数所做的修改将影响实际参数。 被调用的函数必须访问原始参数，而不是访问参数的本地副本。 传值调用（Call by value） 该方法将实际参数（actual arguments）的值复制到函数的形式参数（formal parameters）。这种情况下，在函数内部对形式参数进行修改不会对实际参数产生影响。 默认情况下，C 语言的所有函数参数都是 通过值传递（call by value） 的，意味着函数内的代码不能改变实际参数。也就是说，传递给被调用函数的参数值存放在临时变量中（即拷贝一份副本），而不是存放在原来的变量中。 C 语言中，被调用函数不能直接修改主调函数中变量的值，而只是修改其私有的临时副本的值。 #include int g; void increase(int x, int increment) { x = x + increment; } // 所有函数都是 call by value int main() { printf(\"g: %d\\n\", g); // g: 0 increase(g, 10); printf(\"g: %d\\n\", g); // g: 0 return 0; } 可变参数 type fname(int x,...) 数组参数 当数组名作为实参传递给函数时，传递的是数组第一个元素的地址，而非赋值数组元素本身。在被调用函数中，可以通过数组下标访问或修改数组元素的值。 所以，在定义形参时，采用指针即可。 void max(int *arr) {} 返回值 int main() 的返回值可以省略，其他函数的返回值也可省略。 值传递、指针传递、引用传递 传递方式 函数定义 函数调用 函数副作用 值传递 func(int x) func(a) 无（将 a 复制一份给 x） 指针传递 func(int* x) func(&a) 有（将 a 的内存地址给 x） 引用传递 func(int &x) func(a) 有（x 取 a 的地址） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"function/anonymous.html":{"url":"function/anonymous.html","title":"匿名函数","keywords":"","body":"匿名函数（Anonymous function） 示例 #define max(x, y) ((x, y)->) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"function/call.html":{"url":"function/call.html","title":"函数调用","keywords":"","body":"函数调用（function call） 函数名(0个或多个参数值); 当程序调用函数时，程序控制（program control）将被转移到调用函数。被调用函数执行已定义的任务，当执行其 return 语句或达到其函数结束右括号时，它将程序控制返回给主程序。 为了调用函数，需要传递必需的函数和函数名称，如果函数返回一个值，那么可以存储返回的值。 示例 first.c #include // 函数声明 int max(int, int); int main() { int mx; // 函数调用 mx = max(3, 4); printf(\"%d\\n\", m); return 0; } second.c // 函数定义 int max(int x, int y) { return x > y ? x : y; } 编译 $ gcc first.c second.c -o exe Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"function/declaration.html":{"url":"function/declaration.html","title":"函数声明","keywords":"","body":"函数声明（Function declaration） 函数声明告诉编译器函数的名称、返回类型和函数参数。 语法 返回值类型 函数名(0个或多个参数声明); Return_Type Function_Name(Parameter_List); int max(int x, int y); 在函数声明中参数名称并不重要，重要的是它们的类型。换句话说，函数声明中参数名称可以省略，或者使用跟函数定义不相同的名称： int max(int, int); // 有效 int max(int m, int n); // 有效 何时需要函数声明： 在一个源文件中定义函数而在另一个源文件调用该函数时（不同于 #include 预处理器，这种方式要求两个源文件一起编译） 需要在调用函数前声明该函数。 示例 函数调用 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"function/definition.html":{"url":"function/definition.html","title":"函数定义","keywords":"","body":"函数定义（Function definition） 函数定义提供了函数的实际函数体。 语法 返回值类型 函数名(0个或多个参数声明) { 声明部分 语句序列 } Return_Type Function_Name(Parameter_List) { Function_Body } Return_type（返回类型） 如果存在返回值，返回类型为函数返回值的数据类型 如果没有返回值，返回类型为 void Function Name（函数名） Parameter List 函数可能没有参数 Function Body - 语句集 示例 函数调用 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"function/inline.html":{"url":"function/inline.html","title":"内联函数","keywords":"","body":"内联函数（inline function） 函数会在其所调用的位置上展开。 好处：可以消除函数调用和返回所带来的开销（寄存器存储和恢复） 坏处：代码会变长，意味着占用更多的内存空间或者占用更多的指令缓存 Linux 内核开发者通常把那些对时间要求较高、本身长度较短的函数定义为内联函数。 定义 static inline void wolf(unsigned long tail_size) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/":{"url":"flow-control/","title":"流程控制","keywords":"","body":"流程控制（Flow control）/ 控制流程（Control Flow） C 语言为实现结构良好的程序提供了基本的控制流结构： 语句组 条件判断（if-else） 多路选择（switch） 终止测试在顶部的循环（while、for） 终止测试在底部的循环（do） 提前跳出循环（break） 控制结构 顺序结构 判断结构（if） 循环结构（for、while、do-while） 任何程序可以通过顺序、选择和循环三种方式组成。提倡使用这三种方式进行结构化编程。 break 与 continue continue 只能用在循环体中；break 可以用在循环、条件判断中 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/decision/if.html":{"url":"flow-control/decision/if.html","title":"if 语句","keywords":"","body":"if · else if · else C 语言假定任何非零（non-zero）或非空（non-null）值为 true，如果是零（zero）或空（NULL）则假定为 false 值。 基本语句 if if...else if...else if if...else if..else 通过上述基本语句可以相互嵌套组合成更加复杂的语句形式。 if 语句 语法 if (A) // boolean expression B; // single statement C; // expression if (A) { // boolean expression B; // single or multiple statement(s) } C; // expression 流程图 +---------+ +-----+ false +-----+ +-------+ | (start) | --> | A | -------> | C | --> | (end) | +---------+ +-----+ +-----+ +-------+ | ^ | true | v | +-----+ | | B | ------------+ +-----+ if...else 语句 语法 if (A) // boolean expression B; // single statement else C; // single statement D; if (A) { // boolean expression B; // single or multiple statement(s) } else { C; // single or multiple statement(s) } D; 流程图 +---------+ +--------+ true +-----+ +-----+ +-------+ | (start) | --> | A | ------> | B | --> | D | --> | (end) | +---------+ +--------+ +-----+ +-----+ +-------+ | ^ | false | v | +--------+ | | C | -----------------------+ +--------+ if...else if 语句 语法 （包含一个或多个 else if 块） if (A) // boolean expression B; // single statement else if (C) // boolean expression D; // single statement E; // expression if (A) { // boolean expression B; // single or multiple statement(s) } else if (C) { // boolean expression D; // single or multiple statement(s) } E; // expression 流程图 （混淆点：A == true 时执行完 B 后，是否还要执行 C？当然不需要，不然怎么叫 else if 呢） +---------+ +-------+ true +-----+ +-----+ +-------+ | (start) | --> | A | ------> | B | -----> | E | -----> | (end) | +---------+ +-------+ +-----+ +-----+ +-------+ | ^ | false | v | +-------+ true +-----+ | | C | ------> | D | --------->+ +-------+ +-----+ | | | | false | v | +-------------------------------->+ if...else if...else 语句 语法 （包含一个或多个 else if 块） if (A) // boolean expression B; // single statement else if (C) // boolean expression D; // single statement else E; // single statement F; // expression if (A) { // boolean expression B; // single or multiple statement(s) } else if (C) { // boolean expression D; // single or multiple statement(s) } else { E; // single or multiple statement(s) } F; // expression 流程图 +---------+ +-------+ true +-----+ +-----+ +-------+ | (start) | --> | A | ------> | B | -----> | F | -----> | (end) | +---------+ +-------+ +-----+ +-----+ +-------+ | ^ | false | v | +-------+ true +-----+ | | C | ------> | D | --------->+ +-------+ +-----+ | | | | false | v | +-------+ | | E | ------------------------->+ +-------+ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/decision/switch.html":{"url":"flow-control/decision/switch.html","title":"switch 语句","keywords":"","body":"switch 语句 语法 & 流程图 语法 switch (E) { // expression case C1: // constant expression S1; // single or multiple statement(s) break; // optional case C2: S2; break; default: // optional D; // optional single or multiple statement(s) } F; switch 语句包含零个或多个 case 子语句，以及零个或一个 default 子语句，且可以两者都为空。 S1、S2 可以是零个或多个语句，并且可以使用语句块符号 {} 括起来。 case 的常量表达式必须与 switch 中的变量具有相同的类型 default 语句总是被执行（假设没有 break），而不是当 case 语句都是 false 才执行 流程图 break +---------------------------+ | v +---------+ +---+ E==C1 +----+ default +---+ +---+ +-------+ | (start) | --> | E | -------> | S1 | ---------> | D | --> | F | --> | (end) | +---------+ +---+ +----+ +---+ +---+ +-------+ | ^ ^ | default | | break | E==C2 +----+ | | +----------> | S2 | -------------+---------+ +----+ 示例 #include /* start 2 22 3 defualt end */ int main() { int a = 2; printf(\"start\\n\"); switch (a) { case 1: printf(\"1\\n\"); case 2: printf(\"2\\n\"); printf(\"22\\n\"); case 3: printf(\"3\\n\"); default: printf(\"defualt\\n\"); } printf(\"end\\n\"); return 0; } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/loop/":{"url":"flow-control/loop/","title":"循环结构","keywords":"","body":"循环 循环控制语句 循环控制语句将改变执行程序的正常顺序。 循环控制语句 描述 break 终止循环语句或 switch 语句（以及 if 语句、函数） continue 跳过当前循环体的剩余部分，强制执行循环的下一次迭代 goto 转移控制到带标签的声明 break 语句 break 语句有两种用法： 当 break 语句在循环体时，循环立即终止，程序从循环后的下一个语句开始执行 在 switch 语句中终止 case continue 语句 continue 语句仅用于循环，不可以用于 switch 等语句。 goto 语句 goto 语句提供了从 goto 到同一函数中带标签语句的无条件跳转。 任何编程语言中都建议不要使用 goto 语句，因为它很难跟踪程序的控制流程，使程序难以理解和修改。任何使用 goto 的程序都可以重写或者避免。 语法 goto label; // lable 可以是除关键字以外的任意标识符 ... ... label: statement; goto 如果在循环体内会结束本次循环。 label 后的语句块会照常执行，遇到 goto 之后会再次执行一次 流程图 ``` * 示例 ```c 死循环（Infinite Loop） 如果循环条件一直不变成 false，循环将成为死循环或无限循环。可以使用 Ctrl + C（Unix-like 中代表 “Interrupt”）来结束死循环。 for (;;) { // 缺省条件表达式时，C 语言将假定为 true ... } while (1) { ... } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/loop/do-while.html":{"url":"flow-control/loop/do-while.html","title":"do...while 语句","keywords":"","body":"do...while 语句 语法 do { A; // single or multiple statement(s) } while (B); // condition statement C; // expression A 会在条件测试之前执行一次 while() 后面必须有一个分号，因为是一个语句 流程图 true +-------------+ v | +---------+ +---+ +---+ false +---+ +-------+ | (start) | --> | A | ------> | B | -------> | C | --> | (end) | +---------+ +---+ +---+ +---+ +-------+ 示例 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/loop/for.html":{"url":"flow-control/loop/for.html","title":"for 循环","keywords":"","body":"for 循环 for 语句是对 while 语句的推广，在实际编程过程中，可以选择 while 与 for 中的任意一种循环语句，主要看使用哪一种更清晰。for 语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，因为它将循环语句集中放在一起，且比 while 语句更紧凑。 语法 for (A; B; C) D; // single statement E; // expression // 每一部分可以是任意表达式或者为 **空** for (A; B; C) { D; // single or multiple statement(s) } E; A 是初始化部分（初始化声明在 C99 才支持），仅在进入循环前执行一次 B 是条件部分，循环控制将对该条件求值 如果结果为 true，则执行循环体；执行完循环体后将继续执行 C 如果结果为 false，则终止执行循环 C 是步长部分（可以为空但需要添加到循环体中，否则会进入死循环），用于增加（increment）或减少（decrement）控制变量；执行完该部分后将继续执行 B D 是循环体部分 A、B、C 和 D 均可以为空 流程图 +---------------------------+ v | +---------+ +---+ +-------+ true +---+ +---+ | (start) | --> | A | --> | B | ------> | D | --> | C | +---------+ +---+ +-------+ +---+ +---+ | | false v +-------+ +-------+ | E | ------> | (end) | +-------+ +-------+ for 与 while for 和 while 总是可以通过相互转换得到，例如 while (1) {} 可以转换为 for (;;) {}。 示例 #include // 求 1 ~ 100 之间奇数的和 int main() { int i; int sum; sum = 0; for (i = 0; i Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"flow-control/loop/while.html":{"url":"flow-control/loop/while.html","title":"while 循环","keywords":"","body":"while 循环 while 语句的循环体可以是用花括号 {} 括起来的一条或多条语句，也可以是不用花括号包含的单条语句。for 语句同理。 语法 & 流程图 语法 while (A) // condition expression B; // single statement while (A) { // condition expression B; // single or multiple statement(s) } A 为 non-zero 或 non-null 时值为 true。 流程图 +------------------+ v | +---------+ +-------+ true +-----+ | (start) | --> | A | ------> | B | +---------+ +-------+ +-----+ | | false v +-------+ | (end) | +-------+ 示例 #include // 求 1 ~ 100 之间奇数的和 int main() { int sum; int i; sum = 0; i = 100; while (i > 0) { // 使用 “按位与” 运算判断数字是否为奇数 if (i & 1 == 1) sum = sum + i; i--; } printf(\"%d\\n\", sum); return 0; } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/":{"url":"expression/","title":"表达式","keywords":"","body":"表达式（Expression） 表达式由 运算符（Operator） 和 操作数（Operand） 组成。任何一个表达式，包括赋值表达式和函数调用表达式，都可以是一个语句。 C 语言中，整数除法运算将执行舍位，结果中的小数部分都会被舍弃。 #include int main() { printf(\"%d\\n\", 5 / 9); // 结果为 0 return 0; } #include int main() { printf(\"%f\\n\", 5.0 / 9.0); // 结果为：0.555556 return 0; } #include int main() { printf(\"%.3f\\n\", 5.0 / 9.0); // 结果为：0.556 return 0; } 两种表达式 左值（lvalue）表达式 - 引用了内存位置的表达式；左值可以出现在赋值的左侧或右侧 右值（rvalue）表达式 - 指的是在内存中某个地址的数据值；可能出现在右侧，不能出现在左侧 int g = 20; // 变量是左值 10 = 20; // 数字是右值 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/":{"url":"expression/operator/","title":"运算符","keywords":"","body":"运算符（Operator） 运算（operation） 由 运算符（operator） 和 操作数（operand）组成。 算术运算符 关系运算符 逻辑运算符 按位运算符 自增/自减运算符 其他运算符 条件运算符 赋值运算符 逗号运算符 知识点 C 不支持运算符重载（operator overloading） 参考 Operators in C and C++ C Programming Operators Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/arithmetic-opr.html":{"url":"expression/operator/arithmetic-opr.html","title":"算术运算符","keywords":"","body":"算术运算符（Arithmetic Operator） 运算符 运算（定义） 示例 + 加法（addition） 一元加（unary plus） * a = +a; - 减法或一元减 * 乘法 / 除法 % 取余 C 语言没有提供幂（** 或 ^）、阶乘（!）、求绝对值（|x|）等运算符。 如果某个算术运算符的所有操作数均为整型，则执行整型运算。但是，如果某个算术预算符有一个浮点型运算数和整型运算数，则在 开始运算之前 整型操作数将会被转换成浮点型。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/assignment-opr.html":{"url":"expression/operator/assignment-opr.html","title":"赋值运算符","keywords":"","body":"赋值运算符（Assignment Operators） Operator Syntax Same as Meaning = a = b ~ += a += b a = a + b -= a -= b a = a - b *= a *= b a = a * b /= a /= b a = a / b %= a %= b a = a % b Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/bitwise-opr.html":{"url":"expression/operator/bitwise-opr.html","title":"按位运算符","keywords":"","body":"（按）位运算符（Bitwise Operator） 运算符 汇编等价 含义 Syntax & AND 按位与（Bitwise AND） a & b ` ` OR 按位或（Bitwise inclusive OR） `a b` ^ XOR 按位异或（Bitwise exclusive OR） a ^ b ~ NOT 一元补码（Unary complement） ~a SHL 左移（Shift bits left） a >> SHR 右移（Shift bits right） a >> b Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/increament&decrement-opr.html":{"url":"expression/operator/increament&decrement-opr.html","title":"自增/自减","keywords":"","body":"自增（Self-increasing）/自减（Self-decreasing）运算符 运算符 含义 ++ 自增运算符；使其操作数递增 1 -- 递减运算符；使其操作数递减 1 ++ 和 -- 可以作为前缀运算符（如 ++nc），或者后缀运算符（如 nc++）。 nc++ 在功能上和 nc = nc + 1 等价，但效率更高（寄存器自增？）。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/logical-opr.html":{"url":"expression/operator/logical-opr.html","title":"逻辑运算符","keywords":"","body":"逻辑运算符（Logical Operators） Operator Name Syntax Meaning && 逻辑与（Logic AND） a && b 对连接的表达式从左往右求值，若结果为 false 则立即停止计算 ` ` 逻辑或（Logic OR） `a b` 对连接的表达式从左往右求值，若结果为 true 则立即停止计算 ! 逻辑非（Logic NOT） !a a && b a b a && b true true true true false false false true false false false false a || b a b a \\ \\ b true true true true false true false true true false false false !a a !a true false false true Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/relational-opr.html":{"url":"expression/operator/relational-opr.html","title":"关系运算符","keywords":"","body":"关系运算符（Relational Operators） 关系运算符（Relational Operators） 也叫 比较运算符（Comparison Operators） Operator Meaning Syntax Example == 等于（Equal to） a == b != 不等于（Not equal to） a != b > 大于（Greater than） a > b >= 大于或等于（Greater than or equal to） a >= b 小于（Less than） a 小于或等于（Less than or equal to） a 优先级从上到下依次递减 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"expression/operator/other.html":{"url":"expression/operator/other.html","title":"其他运算符","keywords":"","body":"其他运算符（Other operator） 操作符 含义 示例 sizeof() 返回变量的字节大小 sizeof() & 返回变量的地址 &a * 指向变量的指针 *a ?: 条件运算符（Ternary Operator） if_condition_is_true ? then_value_x : otherwise_value_y 显示类型转换运算符（Explicit type casting operator） int i; float f = 3.14; i = (int) f; 成员和指针运算符（Member and pointer operators） Operator Syntax Meaning 下标（Subscript） a[b] Indirection *a a 指向的对象 Indirection &a a 的地址 三元运算符 conda Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/":{"url":"lexical/","title":"词法规则","keywords":"","body":"词法规则（Lexical Convertions） 记号 空白符 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/":{"url":"lexical/token/","title":"记号","keywords":"","body":"记号（Token） 种类 标识符 关键字 常量 字符串字面量 运算符 其他分隔符（;、,） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/constant/":{"url":"lexical/token/constant/","title":"常量","keywords":"","body":"常量（Constant） Constants refer to fixed values that the program may not alter during its execution. These fixed values are also called literals. 定义后不可以被修改。 常量的值叫做字面量（literal）。 分类 每一种常量都有一个数据类型。 整型常量 字符常量 浮点常量 枚举常量 符号常量？ 常量的定义方式 使用 #define 预处理器；#define 定义的常量也叫符号常量 使用 const 关键字 符号常量（Symbolic constant） #define 指令可以将符号名（或称为符号常量）定义为一个特定的字符串： #define 在该定义之后，程序中出现的所有在 #define 中定义的名字（既没有引号，也不是其他名字的一部分）都将用相应的替换文本替换。 符号常量名通常用大写字母拼写。 #define 指令行的末尾没有分号。 #include #define PI 3.14 #define max(x, y) (x > y ? x : y) // 计算圆的面积 int main() { int r = 5; // 半径 printf(\"%.1f\\n\", PI * r * r); // 78.5 return 0; } const 关键字 可以使用 const 前缀来声明具有特定类型的常量。 大写 -> 好习惯 const = #include int main() { const PI = 3.14; int r; int area; r = 3; area = PI * r * r; printf(\"value of area : %d\\n\", area); return 0; } 参考 Characters in C Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/constant/character-const.html":{"url":"lexical/token/constant/character-const.html","title":"字符常量","keywords":"","body":"字符常量（Character Constant） 字符常量是用单引号 ' 括起来的一个或多个字符构成的序列，例如 'x'。 单字符常量的值是执行时机器字符集中此字符对应的数值。多字符常量的值有具体实现定义。 单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称为字符常量。C 语言使用 ASCII 将字符值编码为数字。 $ man ascii 单引号 '' 括起来的字符是 char 类型，双引号 \"\" 括起来的字符是 char * 类型。 种类 种类 示例 普通字符（plain character） 'x' 转义序列（escape sequence） '\\t' 通用字符（universal character） '\\u020C0' 转义序列（Escape sequences） 普通字符常量不包括换行、回车、\\、 '、? 和 \" 等特殊字符，需要使用转义序列来表示它们： 特殊序列名称 特殊字符缩写 转义序列代码 换行符（newline） NL（LF） \\n 横向制表符（horizontal tab） HT \\t 纵向制表符（vertical tab） VT \\v 回退符（backspace） BS \\b 回车符（carriage return） CR \\r 换页符（formfeed） FF \\f 响铃符（audible alert） BEL \\a 反斜杠（backslash） \\ \\\\ 问号（question mark） ? \\? 单引号（single quote） ' ' 双引号（double quote） \" \" 八进制（octal number） ooo \\ooo 十六进制（hex number） hh \\xhh Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/constant/enumeration-const.html":{"url":"lexical/token/constant/enumeration-const.html","title":"枚举常量","keywords":"","body":"枚举常量（Enumeration Constant） 声明为枚举符的标识符是 int 类型的常量。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/constant/floating-const.html":{"url":"lexical/token/constant/floating-const.html","title":"浮点常量","keywords":"","body":"浮点常量（Floating Constant） 浮点常量的组成 整数部分 小数点 小数部分 指数部分（包含一个 e 或 E、一个可选的带符号整型类型的指数） 类型后缀（f、F、l 或 L） 上面的每一部分都是可选的。整数和小数部分均由数字序列组成。 浮点常量的类型 浮点常量的类型由后缀确定： 后缀 类型 示例 f or F float 111f l or L long double 314E-5L （无） double 3.14 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/constant/integer-const.html":{"url":"lexical/token/constant/integer-const.html","title":"整型常量","keywords":"","body":"整型常量（Integer Constants）/整型字面量（Integer Literals） 整型常量由一串数字组成，可以是十进制、八进制或十六进制。 常量的进制 前缀 进位计数制（system of numeration） 基数 数码 0b or 0B 二进制（binary） 2 [0-1] 0 八进制（octal） 8 [0-7] 0x or 0X 十六进制（hexadecimal） 16 [0-9a-fA-Z] （无） 十进制（decimal） 10 [0-9] 常量的类型 整型常量的类型与它的形式、值和后缀有关。 后缀 类型 u or U unsigned（无符号） l or L long（长整型） UL unsigned long（无符号长整型） 整型常量示例 可能的类型 123 int long int unsigned long int Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/indetifier.html":{"url":"lexical/token/indetifier.html","title":"标识符","keywords":"","body":"标识符（Indentifier） 标识符使用字母和数字构成的序列。第一个字母必须是字母，下划线 _ 也被看作是字母。大写字母和小写字母是不同的。 a-z, A-Z, 0-9, _ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/keyword.html":{"url":"lexical/token/keyword.html","title":"关键字","keywords":"","body":"关键字（Keyword） 下列标识符被保留作为关键字，不同用于其他用途： . . . . auto double int struct break else long switch case enum register typedef char extern return union const float short unsigned continue for signed void default goto sizeof volatile do if static while 某些实现还把 fortran 和 asm 保留为关键字。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/token/string-literal.html":{"url":"lexical/token/string-literal.html","title":"字符串常量","keywords":"","body":"字符串字面量（String literal）/字符串常量（String Constant） 字符串常量是用双引号 \" 括起来的一个或多个字符构成的序列，例如 \"Hello\"。 字符串的类型 字符串的类型为 “字符数组（array of characters）”，存储类为 static。 字符串的内容 字符串常量包含和字符常量相似的字符： 普通字符（plain character） 转义序列（escape sequence） 通用字符（universal character） 表示形式 // 形式一 \"Hello, world\" // 形式二（使用 \\ 分成多行） \"Hello, \\ world\" // 形式三（使用空格分隔它们） \"hello, \" \"w\" \"ord\" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/whitespace/":{"url":"lexical/whitespace/","title":"空白符","keywords":"","body":"空白符（White Space） 空白符（whitespace）是 C 语言中使用的术语。 可以使用 中的 isspace 库函数判断一个字符否为空白符（whitespace）。 种类 空格（blanks） 横向制表符（hirizontal tabs） 纵向制表符（Vertical tabs） 换行符（newlines） 换页符（formfeeds） 注释（comments） 空白符在程序中仅用来分隔记号，因此会被编译器忽略。相邻的标识符、关键字和常量之间需要使用空白符来分隔。 只包含空白（Whitespace），也可能带有注释的行，被称为空行（blank line），编译器会完全忽略它。 空白符（whitespace）将语句的一部分和另一部分分隔开，并使编译器能够识别语句中的每一个元素。形如： int age; // int 和 age 之间至少有一个空白符（通常是一个） fruit = apples + oranges; // 为了增加可读性 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"lexical/whitespace/comments.html":{"url":"lexical/whitespace/comments.html","title":"注释（Comments）","keywords":"","body":"注释（Comments） 注释以字符 /* 开始，以 */ 结束。 注释不能嵌套，也不能出现在字符串字面值或字符字面值中。 C89： /* comment */ C99（C++ 风格）： // comment Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/":{"url":"concept/","title":"概念","keywords":"","body":"基本术语 关键字（keyword） 语句 可执行语句 变量 声明 定义 初始化 初始化声明（initial declaration） 标识符（identifier） 常量 数值常量（numeric constant） 字符常量 符号常量（symbolic constant） 指针常量（pointer constant） 函数 指针 数据类型 流程控制 运算符 表达式 转义字符 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/macro.html":{"url":"concept/macro.html","title":"宏","keywords":"","body":"宏（Macro） 宏定义 #define PI 3.14 // 没有分号 #define max(x, y) (x > y ? x : y) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/process-control/":{"url":"concept/process-control/","title":"进程控制","keywords":"","body":"进程控制（Process control） 参考 C process control Process Control: , Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/scope.html":{"url":"concept/scope.html","title":"作用域","keywords":"","body":"作用域（Scope） 不同作用域的变量 局部变量 全局变量 形式参数 局部变量 在函数或代码块内部声明的变量称为 局部变量（Local Variables）。它们只能在该函数或代码块中被使用。 #include // a、b、c 是 main() 函数的局部变量 int main() { int a, b, c; a = 10; b = 20; c = a + b; printf(\"%d\\n\", c); return 0; } 定义局部变量时，系统不会初始化它，必须自己手动初始化它。 #include void func() { int x; printf(\"%d\\n\", x); } int main() { func(); return 0; } 全局变量 在所有函数外部（通常是在程序顶部）声明的变量，称为 全局变量（Global Variables）。全局变量在程序的整个声明周期保存其值，并且可以在为程序定义的任何函数内访问它们。 任何函数都可以访问全局变量。也就是说，全局变量在声明后可用于整个程序。 #include int g; void increase(int increment) { g = g + increment; } void decrease(int decrement) { g = g - decrement; } int main() { printf(\"g: %d\\n\", g); // g: 0 increase(10); printf(\"g: %d\\n\", g); // g: 10 decrease(5); printf(\"g: %d\\n\", g); // g: 5 return 0; } 局部变量和全局变量可以有相同的名称，但函数内的局部变量的值将优先考虑。 #include // 全局变量声明 int g = 20; int main() { // 局部变量声明 int g = 10; printf(\"g: %d\\n\", g); // g: 10 return 0; } 形式参数 在函数定义中的参数，称为 形式参数（Formal Parameters）。形式参数可以看作是函数内的局部变量，它们优先于全局变量。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/statement.html":{"url":"concept/statement.html","title":"语句","keywords":"","body":"语句（statement） 计算机程序由一系列语句组成。 分类 标签语句（Labeled Statements） 复合语句（Compound Statements） 表达式语句（Expression Statements） 选择语句（Selection Statements） 迭代语句（Iteration Statements） 跳转语句（Jump Statements） 空语句（） 分号 每条语句必须以分号（semicolon）结束，即分号是语句终止符(statement terminator）。 建议每行只写一条语句，并在运算符两边各加上一个空格字符，使运算的关系更清晰明了。 printf(\"Hello, World! \\n\"); // work printf ( \"Hello, World! \\n\" ) ; 语句块 函数语句块 非函数语句块（if、switch、for、while、do） 空语句 C 语言使用一个单独的分号 ; 表示 空语句。 void empty() { ; } 可执行语句 参考 C Programming/Statements Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/storageclass/":{"url":"concept/storageclass/","title":"存储类","keywords":"","body":"存储类（Storage Class） 存储类定义 C 程序中变量和/或函数的作用域（scope）和生命周期（life-time）。 种类 auto register static extern auto 存储类 auto 存储类是所有局部变量（local variables）的默认存储类。auto 只能在函数内部使用。 // 在同一存储类中定义了两个变量 { int mount; auto int mouth; } register 存储类 register 存储类用于定义应该存储在寄存器（register）而不是 RAM 中的局部变量（local variables）。这意味着变量的最大大小等于寄存器大小（通常是一个 word），并且该变量不能使用一元运算符 &（因为它没有内存地址）。 { register int miles; } register 仅应用于需要快速访问的变量，比如计数器。同时还应该注意，定义 register 并不意味着变量将存储在寄存器中，而是 可能 根据硬件和实现限制（implementation restrictions）存储在寄存器中。 #include int main() { register int counters; int i; // 换成 \"register int i;\" 后结果完全不一样 for (i = 0; i static 存储类 static 存储类知识编译器在程序的生命周期内维持一个局部变量，而不是每次进出和超出作用域时创建和销毁它。因此，允许静态局部变量在函数调用之间维持它们的值。 static 修饰符（modifier）也可以用于全局变量，它会将变量的作用域限制在声明它的文件中，并且导致该成员的所有对象共享该成员的一个副本。 #include // 函数声明 void func(void); // 全局变量 static int count = 5; int main() { while (count--) // 试试 --count func(); return 0; } // 函数定义 void func(void) { // 本地 static 变量 static int i = 5; i++; printf(\"i is %d and count is %d\\n\", i, count); } extern 存储类 extern 存储类用于提供全局变量（对所有程序文件可见）的引用。使用 extern 时，无法初始化变量，但它将变量的名称指向先前已定义的存储位置。 extern 用于在另一个文件中 声明 全局变量或函数。 extern 修饰符通常用于在两个或多个文件中共享相同的全局变量或函数。 // First File: main.c #include int count; extern void write_extern(); int main() { count = 5; write_extern(); } // Second File: support.c #include extern int count; void write_extern(void) { printf(\"count is %d\\n\", count); } # 编译两个文件（extern 用于在第二个文件声明 count，而在第一个文件定义 count） $ gcc main.c support.c -o main Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/variable/":{"url":"concept/variable/","title":"遍历","keywords":"","body":"变量（Variable） C 语言中，所有变量必须先声明后使用（即先声明后初始化）。 声明 & 定义 & 初始化 声明（declaration）通常放在函数起始处，在任何可执行语句（executable statement）之前。声明用于描述变量的属性，它由一个 类型名 和 一个 变量列表 组成。 声明的目的是为了告诉编译器变量的类型，并指示编译器在内存中为变量保留空间。 声明变量并不会为变量分配内存空间，它只发生在变量定义（definition）上。 变量的声明（Declaration） 声明用于指定变量、函数、类、命名空间等程序的名称。 未涉及内存的分配。可以多次声明。 // 声明 a 是一个已经定义了的外部变量，变量类型可以去掉 extern int a; // 函数的声明 int add (int p1, int p2); Though you can declare a variable multiple times in your C program, it can be defined only once in a file, a function, or a block of code. 变量的定义（Definition） 涉及对变量的内存分配。仅可以定义一次。初始值是 NULL。 外部变量的定义在所有函数之外。 data_type variable_name; or data_type variable1, variable2, …, variablen; 变量的初始化（Initialization） 变量初始化意味着为变量赋值。 data_type variable_name=constant/literal/expression; or variable_name=constant/literal/expression; 可以在一个语句中用单个值初始化多个变量，如：a=b=c=d=0。 标识符（identifier） C 语言的标识符是一个用于标识变量、函数或其他用户自定义项的名字。 C89 中，以字母（A-Z，a-z）开头（紧接着是零个或多个 A-Z、a-z、0-9）的字母和数字序列。 C99 中，以字母（A-Z，a-z）或下划线（_）开头（紧接着是零个或多个 A-Z、a-z、0-9、_）的字母和数字序列。 C 语言不允许在标识符中存在标点符号（如：@、$、%）。 C 语言是一种大小写敏感（case-sensitive）的编程语言，所以变量 abc、Abc 和 ABC 都不相同。 变量名由字母（A-Z、a-z）、数字（0-9）和下划线（_）组成，且必须以字母或下划线开头。 参考： mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal PI 示例 #include int main() { int x, y; // 声明 int z = 1; // 初始化声明（依然遵循 “先声明后使用” 原则） // 默认值都是 0 printf(\"x is %d, y is %d\\n\", x, y) x = 4; // 初始化 y = 2; // 初始化 printf(\"x is %d, y is %d, z is %d\\n\", x, y, z) return 0; } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"concept/class.html":{"url":"concept/class.html","title":"类","keywords":"","body":"类（Class） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"derective/":{"url":"derective/","title":"指令","keywords":"","body":"C 指令 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"derective/ifdef-else-endif.html":{"url":"derective/ifdef-else-endif.html","title":"ifdef-else-endif","keywords":"","body":"ifdef-else-endif Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"derective/ifndef-else-endif.html":{"url":"derective/ifndef-else-endif.html","title":"ifndef-end-endif","keywords":"","body":"ifndef-end-endif #ifndef 和 #endif 成对出现。 语法 #ifndef // if not defined ... #endif #ifndef /* code */ #else /* code to include if the token is defined */ #endif 用法 /* * header_file.h */ #ifndef HEADER_FILE_H #define HEADER_FILE_H ... #endif 预处理器防止头文件被包含多次 防止递归包含，比如： \"a.h\" 包含 \"b.h\"，而 \"b.h\" 又包含 a.h Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"gc.html":{"url":"gc.html","title":"垃圾回收","keywords":"","body":"垃圾回收 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"translation/":{"url":"translation/","title":"翻译","keywords":"","body":"翻译 程序有存储在文件中的一个或多个翻译单元（translation unit）组成。 程序的翻译阶段 完成低级的词法转换，执行以字符 # 开头的行当中的指令，并进行宏定义（macro defination）和宏扩展（macro expansion）。 预处理完成后，程序被规约成一个记号（token）序列。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"translation/preprocessor/":{"url":"translation/preprocessor/","title":"预处理器","keywords":"","body":"预处理器（Preprocessor） 预处理器命令（Preprocessor commands） #include // 通知 C 编译器在实际编译之前导入标准库文件 stdio.h #include \"header.h\" // 通知 C 编译器在实际编译之前导入本地头文件 header.h 预处理指令 预处理指令 描述 #define 定义宏 #undef 取消宏的定义，即 #define 的反向操作 预定义宏 预定义宏 描述 __FILE__ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"translation/compilation.html":{"url":"translation/compilation.html","title":"编译","keywords":"","body":"编译 编译的预处理阶段将对程序文本进行宏替换、包含其他源文件以及进行条件编译。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"translation/compiler/":{"url":"translation/compiler/","title":"编译器","keywords":"","body":"C 编译器 编译器 GCC （gcc、g++） Xcode Clang MSVC - Microsoft Visual C++ ARM RealView Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"translation/asm-code.html":{"url":"translation/asm-code.html","title":"汇编代码","keywords":"","body":"汇编代码（Assembly Code） 在线网站 Compiler Explorer 可以将源代码转换成汇编代码。 // C int square(int num) { return num * num; } square(int): push rbp mov rbp, rsp mov DWORD PTR [rbp-4], edi mov eax, DWORD PTR [rbp-4] imul eax, DWORD PTR [rbp-4] pop rbp ret Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/auto.html":{"url":"keyword/auto.html","title":"auto","keywords":"","body":"auto Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/define.html":{"url":"keyword/define.html","title":"#define","keywords":"","body":"#define #define LENGTHOF(arr) (sizeof(arr) / sizeof(arr[0])) #define CREATE_ARRAY(array_name, elem_t, size) static elem_t array_name[size] // swap(int, a, b) // swap(char, a, b) // 注：此次是引用传递 #define swap(type_t, x, y) ({ \\ type_t temp; \\ temp = x; \\ x = y; \\ y = temp; \\ }) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/ifdef-endif.html":{"url":"keyword/ifdef-endif.html","title":"#ifdef...#endif","keywords":"","body":"#ifdef...#endif Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/ifndef-endif.html":{"url":"keyword/ifndef-endif.html","title":"#ifndef ... #endif","keywords":"","body":"#ifndef ... #endif 如果一个头文件被引用两次，C 编译器会处理两次文件的内容。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/include.html":{"url":"keyword/include.html","title":"include","keywords":"","body":"include #include // 通知预处理器从标准库中导入 #include \"header.h\" // 通知预处理器从本地目录导入 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/inline.html":{"url":"keyword/inline.html","title":"inline","keywords":"","body":"C 关键字 · inline Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/register.html":{"url":"keyword/register.html","title":"register","keywords":"","body":"register Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/static.html":{"url":"keyword/static.html","title":"static","keywords":"","body":"C 关键字 · static 类型关键字 unsigned void struct int long Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"keyword/typedef.html":{"url":"keyword/typedef.html","title":"typedef","keywords":"","body":"typedef 对已有数据类型指定别名。 语法 typedef ; 示例 typedef unsigned int uint; struct node { int data; struct node* next; }; typedef struct node Node; /*----- 等同于 -----*/ typedef struct node { int data; struct node* next; } Node; Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/":{"url":"libc/","title":"libc","keywords":"","body":"C 标准库 C 标准库（C standard library，缩写为 libc）， 名字 源自 描述 类别/实现 正如 ANSI C 是 C 语言的标准一样，libc 也是一种函数库标准，每个操作系统都可能按照该标准对标准库进行具体实现。 libc - ANSI C 的标准库 glibc - GNU C 的标准库，针对 GNU 操作系统、以 GNU/Linux 为内核的操作系统 BSD libc GNU C library Microsoft C run-time library：它是 Microsoft Visual C++ 的一部分 Bionic 参考 C 标准函数库 Difference between C standard library and C POSIX library Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/assert-h/":{"url":"libc/stdlib/assert-h/","title":"assert.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/ctype-h/":{"url":"libc/stdlib/ctype-h/","title":"ctype.h","keywords":"","body":"ctype.h 库函数 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/errno-h/":{"url":"libc/stdlib/errno-h/","title":"errno.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/float-h/":{"url":"libc/stdlib/float-h/","title":"float.h","keywords":"","body":"float.h 宏（macros） FLT_MIN FLT_MAX FLT_DIG Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/limits-h/":{"url":"libc/stdlib/limits-h/","title":"limits.h","keywords":"","body":" - sizes of integer types 宏（macros） CHAR_BIT Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/locale-h/":{"url":"libc/stdlib/locale-h/","title":"locale.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/math-h/":{"url":"libc/stdlib/math-h/","title":"math.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/setjmp-h/":{"url":"libc/stdlib/setjmp-h/","title":"setjmp.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/signal-h/":{"url":"libc/stdlib/signal-h/","title":"signal.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/stdarg-h/":{"url":"libc/stdlib/stdarg-h/","title":"stdarg.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/stddef-h/":{"url":"libc/stdlib/stddef-h/","title":"stddef.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/stdio-h/":{"url":"libc/stdlib/stdio-h/","title":"stdio.h","keywords":"","body":"stdio.h stdio 即 standard input/output C 语言本身并没有定义输入输出功能。常用的 printf 函数仅仅是标准库 中的一个有用的函数而已。 格式化输入/输出（Formatted input/output） 字符输入/输出（character input/output） 无论文本从何处输入，输出到何处，其输入/输出都是按 字符流（character stream） 的方式处理。文本流 是由多行字符构成的字符序列，而每行字符则由 0 个或多个字符组成，行末是一个换行符。标准库负责使每个输入/输出流都能够遵循这一模型。 getchar() - 从文本流中读入下一个输入字符，并将其作为结果值返回 putchar() - 打印一个字符（没有换行） EOF #include int main() { printf(\"%d\\n\", EOF); // -1 } 参考 (stdio.h) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/stdio-h/getchar-and-putchar.html":{"url":"libc/stdlib/stdio-h/getchar-and-putchar.html","title":"getchar/putchar","keywords":"","body":"getchar & putchar 示例 文件复制（copy.c） #include // 版本一 void cp_v1() { int c; // 不能用 char 的原因是还要存储文件结束符 EOF（它不是一个字符） c = getchar(); while (c != EOF) // EOF: 文件结束指示符 { putchar(c); c = getchar(); } } // 版本二 void cp_v2() { int c; while ((c = getchar()) != EOF) putchar(c); } int main() { cp_v1(); // cp_v2(); return 0; } # 编译 $ gcc copy.c -o copy # 测试一 $ echo -e \"hello\\nworld\" > README.md # 重定向输出 $ ./copy 字符计数（charcount.c） #include long cc_v1() { long count; for (count = 0; getchar() != EOF;) count++; // 效率比 “count = count + 1” 高 return count; } long cc_v2() { long count = 0; while (getchar() != EOF) count++; return count; } int main() { long count; count = cc_v1(); // count = cc_v2(); printf(\"%ld\\n\", count); } # 编译 $ gcc countofchar.c -o countofchar # 测试 $ ./countofchar 1234 # 输入第一行 5678 # 输入第二行 10 # 按 Ctrl+D（表示文件换行符 EOF） 后的输出，上面每行有一个换行符 行计数（linecount.c） #include int main() { int c; long line; line = 0; while ((c = getchar()) != EOF) { if (c == '\\n') line++; } printf(\"%ld\\n\", line); } # 编译 $ gcc linecount.c -o linecount # 测试 $ ./linecount 123456 # 输入第一行 abcdef # 输入第二行 2 # 按 Ctrl+D（表示文件换行符 EOF） 后的输出 单词计数（wordcount.c） #include int main() { int c; while ((c = getchar()) != EOF) { } } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/stdio-h/printf.html":{"url":"libc/stdlib/stdio-h/printf.html","title":"printf","keywords":"","body":"库函数 printf 格式符 含义 %d 按照十进制整数（int）打印 %6d 按照十进制整数打印，至少 6 个字符宽 %f 按照浮点数（float）打印 %6f 按照浮点数打印，至少 6 个字符宽 %.0f 按照浮点数打印，不保留小数和小数点 %.2f 按照浮点数打印，保留两位小数 %6.2f 按照浮点数打印，保留两位小数，至少 6 个字符宽（整数部分 + 小数部分 + 点） %o 按照八进制数打印 %x 按照十六进制数打印 %c 打印字符（char） %s 打印字符串（character strings） %% 打印百分号（%）本身 示例 #include int main() { printf(\"%x\\n\", 17); // 11 } Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/stdlib-h/":{"url":"libc/stdlib/stdlib-h/","title":"stdlib.h","keywords":"","body":" 内存管理： 函数 描述 calloc() malloc() realloc() free() 必须检查 calloc、malloc 或 realloc 的返回值是否为 NULL，因为当内存不足时将返回 NULL calloc() // 动态分配 `num(数量) * size(字节)` 个字节的连续内存空间 void *calloc(size_t nitems, size_t size) // 示例 char* ptr = (char *) calloc(10, sizeof(int)); 每个字节默认初始化为 0 返回值是连续内存空间的起始地址（指针） malloc() // 动态分配 size 个字节的连续内存空间 void *malloc(size_t size); 内存空间未被初始化 返回值是连续内存空间的起始地址（指针） realloc() // 调整之前调用 malloc 或 calloc 时所分配（由 ptr 所指向的）的内存的大小 void *realloc(void *ptr, size_t new_size) 缩容（new_size 扩容（new_size > size） 如果原内存空间后面有足够内存，直接在尾部新增 new_size - size 字节大小的内存 如果原内存空间后面无足够内存，重新分配一块 new_size 字节大小的内存空间，并将原内存中的数据复制到新内存 free() // 释放之前调用 calloc、malloc 或 realloc 时所分配的内存空间 void free(void *ptr); 参数要么是 NULL，要么是 malloc()、calloc() 或 realloc() 返回的指针 参考 C — 动态内存分配之 malloc 与 realloc 的区别 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/string-h/":{"url":"libc/stdlib/string-h/","title":"string.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/stdlib/time-h/":{"url":"libc/stdlib/time-h/","title":"time.h","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/glibc/":{"url":"libc/glibc/","title":"glibc","keywords":"","body":" Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/glibc/__attribute__.html":{"url":"libc/glibc/__attribute__.html","title":"attribute","keywords":"","body":"__attribute__ __attribute__ 可以设置函数属性（Function Attribute）、变量属性（Variable Attribute）、类型属性（Type Attribute）。 语法 __attribute__((属性列表)) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/bionic/":{"url":"libc/bionic/","title":"bionic","keywords":"","body":"Bionic 参考 Bionic_(software)) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libc/msvc/":{"url":"libc/msvc/","title":"msvc","keywords":"","body":"Microsoft Visual C++ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"appendix/style-guide.html":{"url":"appendix/style-guide.html","title":"代码规范","keywords":"","body":"C 代码风格（C coding style） 命名 缩进 大括号和空格的放置 大括号和空格的放置 注释 格式化 头文件 作用域 类 命名 缩进 制表符是 8 个字符，所以缩进也是 8 个字符。 理由：缩进的全部意义就在于清楚的定义一个控制块起止于何处。 8 个字符的缩进可以让代码更容易阅读，还有一个好处是当你的函数嵌套太 深的时候可以给你警告。留心这个警告。 不要把多个语句放在一行 不要在一行放多个赋值语言 除了注释、文档和 Kconfig 之外，不要使用空格来缩进 选用一个好的编辑器，不要在行尾留空格 在 switch 语句中消除多级缩进的首选的方式是让 switch 和从属于它的 case 标签对齐于同一列，而不要 两次缩进 case 标签 switch (suffix) { case 'G': case 'g': mem 把长的行和字符串打散 每一行的长度限制在 80 列 长于 80 列的语句要打散成有意义的片段。除非超过 80 列能显著增加可读性，并且不 会隐藏信息。子片段要明显短于母片段，并明显靠右。这同样适用于有着很长参数列表 的函数头。然而，绝对不要打散对用户可见的字符串，例如 printk 信息，因为这样就很难对它们 grep。 大括号和空格的放置 首选的方式，就像 Kernighan 和 Ritchie 展示 给我们的，是把起始大括号放在行尾，而把结束大括号放在行首，所以： if (x is true) { we do y } 有一个例外，那就是函数：函数的起始大括号放置于下一行的开头，所以： int function(int x) { body of function } 注意结束大括号独自占据一行，除非它后面跟着同一个语句的剩余部分，也就是 do 语 句中的 “while” 或者 if 语句中的 “else” do { body of do-loop } while (condition); if (x == y) { .. } else if (x > y) { ... } else { .... } 当只有一个单独的语句的时候，不用加不必要的大括号 if (condition) action(); if (condition) do_this(); else do_that(); 这并不适用于只有一个条件分支是单语句的情况；这时所有分支都要使用大括号： if (condition) { do_this(); do_that(); } else { otherwise(); } 参考 Linux 内核代码风格 Google C++ Style Guide Making The Best Use of C C++ 风格指南 - 内容目录 谷歌编程风格指南_C语言版 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "}}